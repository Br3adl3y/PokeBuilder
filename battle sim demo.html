<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Simulator Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 {
            text-align: center;
            color: #cc0000;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        .battle-setup {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .pokemon-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .pokemon-card h2 {
            margin-top: 0;
            color: #333;
        }
        label {
            display: block;
            margin: 10px 0 5px;
            font-weight: bold;
            font-size: 14px;
        }
        select, input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        .control-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 18px;
            font-weight: bold;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .results {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .winner {
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            padding: 25px;
            margin: 20px 0;
            border-radius: 8px;
        }
        .winner.p1 {
            background: #e3f2fd;
            color: #1976d2;
        }
        .winner.p2 {
            background: #fce4ec;
            color: #c2185b;
        }
        .winner.tie {
            background: #fff3e0;
            color: #f57c00;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .stat-card {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
        }
        .stat-card h3 {
            margin-top: 0;
            color: #666;
        }
        .hp-bar {
            background: #ddd;
            height: 30px;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        .hp-fill {
            background: #4CAF50;
            height: 100%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }
        .battle-log {
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.5;
        }
        .error {
            background: #ffebee;
            border: 1px solid #ef5350;
            padding: 15px;
            border-radius: 4px;
            color: #c62828;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>‚öîÔ∏è Pokemon GO Battle Simulator - Test Page</h1>

    <div id="loading" class="loading">Loading database...</div>
    <div id="error" class="error" style="display:none;"></div>

    <div id="app" style="display:none;">
        <div class="battle-setup">
            <div class="pokemon-card">
                <h2>Pokemon 1 (Blue Corner)</h2>
                <label>Select Pokemon:</label>
                <select id="p1-select" onchange="loadPokemon(1)"></select>
                
                <label>Fast Move:</label>
                <select id="p1-fast"></select>
                
                <label>Charged Move 1:</label>
                <select id="p1-charge1"></select>
                
                <label>Charged Move 2:</label>
                <select id="p1-charge2"></select>
                
                <label><input type="checkbox" id="p1-shadow"> Shadow</label>
            </div>

            <div class="pokemon-card">
                <h2>Pokemon 2 (Red Corner)</h2>
                <label>Select Pokemon:</label>
                <select id="p2-select" onchange="loadPokemon(2)"></select>
                
                <label>Fast Move:</label>
                <select id="p2-fast"></select>
                
                <label>Charged Move 1:</label>
                <select id="p2-charge1"></select>
                
                <label>Charged Move 2:</label>
                <select id="p2-charge2"></select>
                
                <label><input type="checkbox" id="p2-shadow"> Shadow</label>
            </div>
        </div>

        <div class="controls">
            <div class="control-row">
                <div>
                    <label>P1 Shields:</label>
                    <select id="shields-p1">
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                    </select>
                </div>
                
                <div>
                    <label>P2 Shields:</label>
                    <select id="shields-p2">
                        <option value="0">0</option>
                        <option value="1">1</option>
                        <option value="2" selected>2</option>
                    </select>
                </div>
                
                <div>
                    <label>Scenario:</label>
                    <select id="scenario">
                        <option value="leads">Leads (Even)</option>
                        <option value="closers">Closers (0v0)</option>
                        <option value="baited">Baited</option>
                        <option value="baitor">Baitor</option>
                        <option value="switches">Switches</option>
                        <option value="attackers">Attackers (0v2)</option>
                    </select>
                </div>
            </div>
            
            <br>
            <button onclick="runBattle()">‚öîÔ∏è SIMULATE BATTLE</button>
        </div>

        <div id="results" class="results" style="display:none;">
            <div id="winner-banner"></div>
            
            <div class="stats-grid">
                <div class="stat-card">
                    <h3 id="p1-name-result"></h3>
                    <div class="hp-bar">
                        <div class="hp-fill" id="p1-hp-bar"></div>
                    </div>
                    <p>Energy: <span id="p1-energy-result"></span></p>
                    <p>Shields: <span id="p1-shields-result"></span></p>
                </div>
                
                <div class="stat-card">
                    <h3 id="p2-name-result"></h3>
                    <div class="hp-bar">
                        <div class="hp-fill" id="p2-hp-bar"></div>
                    </div>
                    <p>Energy: <span id="p2-energy-result"></span></p>
                    <p>Shields: <span id="p2-shields-result"></span></p>
                </div>
            </div>
            
            <h3>Battle Rating: <span id="battle-rating"></span> | Turns: <span id="total-turns"></span></h3>
            
            <h3>Battle Log:</h3>
            <div class="battle-log" id="battle-log"></div>
        </div>
    </div>

    <script>
        let db, allPokemon, allMoves, typeChart;
        const pokemonData = {};

        async function initDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('PokemonGoDB', 2);
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        async function loadData() {
            try {
                db = await initDatabase();
                
                // Load all Pokemon
                const pokemonTx = db.transaction(['pokemon'], 'readonly');
                allPokemon = await new Promise((resolve, reject) => {
                    const req = pokemonTx.objectStore('pokemon').getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
                
                // Load all moves
                const movesTx = db.transaction(['moves'], 'readonly');
                allMoves = await new Promise((resolve, reject) => {
                    const req = movesTx.objectStore('moves').getAll();
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
                
                // Load type effectiveness
                const typeTx = db.transaction(['typeEffectiveness'], 'readonly');
                const damageMatrixData = await new Promise((resolve, reject) => {
                    const req = typeTx.objectStore('typeEffectiveness').get('damageMatrix');
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                });
                // Convert matrix to object format
                typeChart = {};
                const matrix = damageMatrixData.matrix;
                const attackerTypes = damageMatrixData.attackerTypes;  // 18 types
                const defenderTypes = damageMatrixData.defenderTypes; // ‚Üê CHANGED FROM typeOrder
                attackerTypes.forEach((attackType, i) => {
                    typeChart[attackType] = {};
                    defenderTypes.forEach((defType, j) => {
                        typeChart[attackType][defType] = matrix[i][j];
                    });
                });

                // Filter to Great League eligible
                const greatLeague = allPokemon.filter(p => p.maxCP >= 1400);
                
                populatePokemonSelects(greatLeague);
                
                document.getElementById('loading').style.display = 'none';
                document.getElementById('app').style.display = 'block';
                
                // Load defaults
                loadPokemon(1);
                loadPokemon(2);
                
            } catch (error) {
                document.getElementById('loading').style.display = 'none';
                document.getElementById('error').style.display = 'block';
                document.getElementById('error').textContent = `Error loading database: ${error.message}. Make sure you've run the scraper first!`;
            }
        }

        function populatePokemonSelects(pokemon) {
            const p1Select = document.getElementById('p1-select');
            const p2Select = document.getElementById('p2-select');
            
            pokemon.sort((a, b) => a.name.localeCompare(b.name));
            
            pokemon.forEach(p => {
                const label = p.form ? `${p.name} (${p.form})` : p.name;
                
                const opt1 = document.createElement('option');
                opt1.value = p.id;
                opt1.textContent = label;
                p1Select.appendChild(opt1);
                
                const opt2 = document.createElement('option');
                opt2.value = p.id;
                opt2.textContent = label;
                p2Select.appendChild(opt2);
            });
            
            // Set defaults
            p1Select.value = 'Azumarill-base';
            p2Select.value = 'Registeel-base';
        }

        function loadPokemon(playerNum) {
            const selectId = `p${playerNum}-select`;
            const pokemonId = document.getElementById(selectId).value;
            const pokemon = allPokemon.find(p => p.id === pokemonId);
            
            if (!pokemon) return;
            
            pokemonData[`p${playerNum}`] = pokemon;
            
            // Populate fast moves
            const fastSelect = document.getElementById(`p${playerNum}-fast`);
            fastSelect.innerHTML = '';
            pokemon.moves.fast.forEach(moveName => {
                const move = allMoves.find(m => m.name === moveName && m.mode === 'pvp' && m.category === 'fast');
                if (move) {
                    const opt = document.createElement('option');
                    opt.value = move.rawId;
                    opt.textContent = `${move.name} (${move.type}, ${move.power} pow, ${move.energy} energy, ${move.duration} turns)`;
                    fastSelect.appendChild(opt);
                }
            });
            
            // Populate charged moves
            const charge1Select = document.getElementById(`p${playerNum}-charge1`);
            const charge2Select = document.getElementById(`p${playerNum}-charge2`);
            charge1Select.innerHTML = '';
            charge2Select.innerHTML = '';
            
            const allChargedMoves = [...pokemon.moves.charge, ...pokemon.moves.chargeElite];
            allChargedMoves.forEach(moveName => {
                const move = allMoves.find(m => m.name === moveName && m.mode === 'pvp' && m.category === 'charge');
                if (move) {
                    const opt1 = document.createElement('option');
                    opt1.value = move.rawId;
                    opt1.textContent = `${move.name} (${move.type}, ${move.power} pow, ${move.energy} energy)`;
                    charge1Select.appendChild(opt1.cloneNode(true));
                    
                    const opt2 = document.createElement('option');
                    opt2.value = move.rawId;
                    opt2.textContent = `${move.name} (${move.type}, ${move.power} pow, ${move.energy} energy)`;
                    charge2Select.appendChild(opt2);
                }
            });
        }

        function getMoveByRawId(rawId, category) {
            return allMoves.find(m => m.rawId === rawId && m.category === category && m.mode === 'pvp');
        }

        function runBattle() {
            const p1 = pokemonData.p1;
            const p2 = pokemonData.p2;
            
            if (!p1 || !p2) {
                alert('Please select both Pokemon first!');
                return;
            }
            
            const p1FastId = document.getElementById('p1-fast').value;
            const p1Charge1Id = document.getElementById('p1-charge1').value;
            const p1Charge2Id = document.getElementById('p1-charge2').value;
            
            const p2FastId = document.getElementById('p2-fast').value;
            const p2Charge1Id = document.getElementById('p2-charge1').value;
            const p2Charge2Id = document.getElementById('p2-charge2').value;
            
            const pokemon1 = {
                name: p1.name,
                types: p1.types,
                stats: p1.stats,
                ivs: { ...p1.great.iv, cpm: 0.7317 },
                fastMove: getMoveByRawId(p1FastId, 'fast'),
                chargedMoves: [
                    getMoveByRawId(p1Charge1Id, 'charge'),
                    getMoveByRawId(p1Charge2Id, 'charge')
                ].filter(m => m),
                isShadow: document.getElementById('p1-shadow').checked
            };
            
            const pokemon2 = {
                name: p2.name,
                types: p2.types,
                stats: p2.stats,
                ivs: { ...p2.great.iv, cpm: 0.7186 },
                fastMove: getMoveByRawId(p2FastId, 'fast'),
                chargedMoves: [
                    getMoveByRawId(p2Charge1Id, 'charge'),
                    getMoveByRawId(p2Charge2Id, 'charge')
                ].filter(m => m),
                isShadow: document.getElementById('p2-shadow').checked
            };
            
            const shields1 = parseInt(document.getElementById('shields-p1').value);
            const shields2 = parseInt(document.getElementById('shields-p2').value);
            const scenario = document.getElementById('scenario').value;
            
            const sim = new BattleSimulator(pokemon1, pokemon2, shields1, shields2, scenario, typeChart);
            sim.setDeterministicMode(true);
            
            const rating = sim.simulate();
            const summary = sim.getBattleSummary();
            const log = sim.getLog();
            
            // Display results
            const resultsDiv = document.getElementById('results');
            resultsDiv.style.display = 'block';
            resultsDiv.scrollIntoView({ behavior: 'smooth' });
            
            // Winner banner
            const winnerBanner = document.getElementById('winner-banner');
            let winnerClass = 'tie';
            let winnerText = 'TIE!';
            
            if (summary.winner === 'P1') {
                winnerClass = 'p1';
                winnerText = `üèÜ ${pokemon1.name} WINS!`;
            } else if (summary.winner === 'P2') {
                winnerClass = 'p2';
                winnerText = `üèÜ ${pokemon2.name} WINS!`;
            }
            
            winnerBanner.className = 'winner ' + winnerClass;
            winnerBanner.textContent = winnerText;
            
            // P1 stats
            document.getElementById('p1-name-result').textContent = pokemon1.name;
            document.getElementById('p1-hp-bar').style.width = summary.p1.hpPercent + '%';
            document.getElementById('p1-hp-bar').textContent = `${summary.p1.hp}/${summary.p1.maxHP} (${summary.p1.hpPercent}%)`;
            document.getElementById('p1-energy-result').textContent = summary.p1.energy;
            document.getElementById('p1-shields-result').textContent = summary.p1.shields;
            
            // P2 stats
            document.getElementById('p2-name-result').textContent = pokemon2.name;
            document.getElementById('p2-hp-bar').style.width = summary.p2.hpPercent + '%';
            document.getElementById('p2-hp-bar').textContent = `${summary.p2.hp}/${summary.p2.maxHP} (${summary.p2.hpPercent}%)`;
            document.getElementById('p2-energy-result').textContent = summary.p2.energy;
            document.getElementById('p2-shields-result').textContent = summary.p2.shields;
            
            // Battle rating
            document.getElementById('battle-rating').textContent = Math.round(rating);
            document.getElementById('total-turns').textContent = summary.turns;
            
            // Battle log
            document.getElementById('battle-log').textContent = log.join('\n');
        }

        // Initialize on load
        loadData();
    </script>
    
    <!-- Battle Simulator Core (embedded from pogo_battle_sim artifact) -->
    <script>
        class BattleSimulator {
            constructor(pokemon1, pokemon2, shields1, shields2, scenario, typeChart) {
                this.p1 = pokemon1;
                this.p2 = pokemon2;
                this.shields = [shields1, shields2];
                this.energy = [0, 0];
                this.hp = [
                    this.calculateHP(pokemon1.stats, pokemon1.ivs),
                    this.calculateHP(pokemon2.stats, pokemon2.ivs)
                ];
                this.maxHP = [...this.hp];
                this.attackStage = [0, 0];
                this.defenseStage = [0, 0];
                this.turn = 0;
                this.fastMoveCountdown = [0, 0];
                this.log = [];
                this.scenario = scenario;
                this.typeChart = typeChart;
                this.deterministicMode = false;
            }

            setDeterministicMode(enabled) {
                this.deterministicMode = enabled;
            }

            simulate() {
                this.applyScenarioConditions();
                
                while (this.hp[0] > 0 && this.hp[1] > 0) {
                    this.processTurn();
                    this.turn++;
                    if (this.turn > 1000) break;
                }
                
                return this.calculateBattleRating();
            }

            applyScenarioConditions() {
                if (this.scenario === 'switches') {
                    this.energy[1] = this.p2.fastMove.energy * 6;
                }
            }

            processTurn() {
                this.fastMoveCountdown[0]--;
                this.fastMoveCountdown[1]--;
                
                if (this.fastMoveCountdown[0] <= 0) {
                    this.useFastMove(0);
                    this.fastMoveCountdown[0] = this.p1.fastMove.duration;
                }
                
                if (this.fastMoveCountdown[1] <= 0) {
                    this.useFastMove(1);
                    this.fastMoveCountdown[1] = this.p2.fastMove.duration;
                }
                
                this.checkChargedMoves();
            }

            useFastMove(attackerIndex) {
                const attacker = attackerIndex === 0 ? this.p1 : this.p2;
                const defenderIndex = 1 - attackerIndex;
                const defender = attackerIndex === 0 ? this.p2 : this.p1;
                
                const move = attacker.fastMove;
                const damage = this.calculateDamage(attacker, defender, move, attackerIndex, defenderIndex);
                
                this.hp[defenderIndex] -= damage;
                this.hp[defenderIndex] = Math.max(0, this.hp[defenderIndex]);
                
                this.energy[attackerIndex] += move.energy;
                this.energy[attackerIndex] = Math.min(100, this.energy[attackerIndex]);
                
                this.log.push(`Turn ${this.turn}: P${attackerIndex + 1} ${move.name} ‚Üí ${damage} dmg`);
            }

            checkChargedMoves() {
                const p1Ready = this.canUseChargedMove(0);
                const p2Ready = this.canUseChargedMove(1);
                
                if (p1Ready && p2Ready) {
                    const p1Attack = this.getEffectiveAttack(0);
                    const p2Attack = this.getEffectiveAttack(1);
                    
                    if (p1Attack >= p2Attack) {
                        this.useChargedMove(0);
                        if (this.hp[1] > 0) this.useChargedMove(1);
                    } else {
                        this.useChargedMove(1);
                        if (this.hp[0] > 0) this.useChargedMove(0);
                    }
                } else if (p1Ready) {
                    this.useChargedMove(0);
                } else if (p2Ready) {
                    this.useChargedMove(1);
                }
            }

            canUseChargedMove(playerIndex) {
                const pokemon = playerIndex === 0 ? this.p1 : this.p2;
                if (pokemon.chargedMoves.length === 0) return false;
                
                const cheapestMove = pokemon.chargedMoves.reduce((min, move) => 
                    move.energy < min.energy ? move : min
                );
                
                return this.energy[playerIndex] >= cheapestMove.energy;
            }

            useChargedMove(attackerIndex) {
                const attacker = attackerIndex === 0 ? this.p1 : this.p2;
                const defenderIndex = 1 - attackerIndex;
                const defender = attackerIndex === 0 ? this.p2 : this.p1;
                
                const move = this.selectChargedMove(attackerIndex, defenderIndex);
                if (!move) return;
                
                this.energy[attackerIndex] -= move.energy;
                this.energy[attackerIndex] = Math.max(0, this.energy[attackerIndex]);
                
                let damage = this.calculateDamage(attacker, defender, move, attackerIndex, defenderIndex);
                
                const shouldShield = this.shouldUseShield(defenderIndex, move);
                
                if (shouldShield) {
                    this.shields[defenderIndex]--;
                    damage = 1;
                    this.log.push(`Turn ${this.turn}: P${defenderIndex + 1} SHIELDS ${move.name}`);
                }
                
                this.hp[defenderIndex] -= damage;
                this.hp[defenderIndex] = Math.max(0, this.hp[defenderIndex]);
                
                this.log.push(`Turn ${this.turn}: P${attackerIndex + 1} ${move.name} ‚Üí ${damage} dmg`);
            }

            selectChargedMove(attackerIndex, defenderIndex) {
                const attacker = attackerIndex === 0 ? this.p1 : this.p2;
                const defender = defenderIndex === 0 ? this.p1 : this.p2;

                console.log(`\n=== P${attackerIndex + 1} (${attacker.speciesName}) has ${this.energy[attackerIndex]} energy ===`);
                console.log(`All charged moves:`, attacker.chargedMoves.map(m => `${m.name} (${m.energy} energy)`));

                const moves = attacker.chargedMoves.filter(m => 
                    this.energy[attackerIndex] >= m.energy
                );
                
                if (moves.length === 0) return null;
                if (moves.length === 1) return moves[0];
                
                const defenderHasShields = this.shields[defenderIndex] > 0;
                
                // Baited scenario: throw cheapest when shields are up
                if (this.scenario === 'baited' && defenderHasShields) {
                    return moves.sort((a, b) => a.energy - b.energy)[0];
                }
                
                // Baitor scenario OR default: always pick optimal DPE move
                // This matches PVPoke's "optimal moveset for every matchup"
                return moves.sort((a, b) => {
                    const effA = this.getTypeEffectiveness(a.type, defender.types);
                    const effB = this.getTypeEffectiveness(b.type, defender.types);
                    const dpeA = (a.power / a.energy) * effA;
                    const dpeB = (b.power / b.energy) * effB;
                    return dpeB - dpeA;
                })[0];
            }

            shouldUseShield(defenderIndex, move) {
                if (this.shields[defenderIndex] === 0) return false;
                
                const attacker = defenderIndex === 0 ? this.p2 : this.p1;
                const attackerMoves = attacker.chargedMoves;
                
                switch (this.scenario) {
                    case 'baited':
                        return true;
                        
                    case 'baitor':
                        if (attackerMoves.length === 1) return true;
                        
                        const sorted = [...attackerMoves].sort((a, b) => {
                            if (a.energy !== b.energy) return a.energy - b.energy;
                            return a.power - b.power;
                        });
                        
                        const cheapestMove = sorted[0];
                        return move.energy > cheapestMove.energy || 
                               (move.energy === cheapestMove.energy && move.power > cheapestMove.power);
                        
                    default:
                        return true;
                }
            }

            calculateDamage(attacker, defender, move, attackerIndex, defenderIndex) {
                const attackStat = this.getEffectiveAttack(attackerIndex);
                const defenseStat = this.getEffectiveDefense(defenderIndex);
                const effectiveness = this.getTypeEffectiveness(move.type, defender.types);
                const stabMultiplier = attacker.types.includes(move.type) ? 1.2 : 1.0;
                
                const baseDamage = 0.5 * move.power * (attackStat / defenseStat) * effectiveness * stabMultiplier;
                const damage = Math.floor(baseDamage) + 1;
                
                return damage;
            }

            getEffectiveAttack(playerIndex) {
                const pokemon = playerIndex === 0 ? this.p1 : this.p2;
                const baseAttack = this.calculateAttack(pokemon.stats, pokemon.ivs);
                const shadowMultiplier = pokemon.isShadow ? 1.2 : 1.0;
                const stageMultiplier = this.getStageMultiplier(this.attackStage[playerIndex]);
                
                return baseAttack * shadowMultiplier * stageMultiplier;
            }

            getEffectiveDefense(playerIndex) {
                const pokemon = playerIndex === 0 ? this.p1 : this.p2;
                const baseDefense = this.calculateDefense(pokemon.stats, pokemon.ivs);
                const shadowMultiplier = pokemon.isShadow ? 0.833 : 1.0;
                const stageMultiplier = this.getStageMultiplier(this.defenseStage[playerIndex]);
                
                return baseDefense * shadowMultiplier * stageMultiplier;
            }

            getStageMultiplier(stage) {
                const multipliers = {
                    '-4': 0.5, '-3': 0.5714, '-2': 0.6667, '-1': 0.8,
                    '0': 1.0,
                    '1': 1.25, '2': 1.5, '3': 1.75, '4': 2.0
                };
                return multipliers[stage.toString()] || 1.0;
            }

            calculateAttack(stats, ivs) {
                const cpm = ivs.cpm || 0.84030001;
                return (stats.attack + ivs.atk) * cpm;
            }

            calculateDefense(stats, ivs) {
                const cpm = ivs.cpm || 0.84030001;
                return (stats.defense + ivs.def) * cpm;
            }

            calculateHP(stats, ivs) {
                const cpm = ivs.cpm || 0.84030001;
                return Math.max(10, Math.floor((stats.hp + ivs.sta) * cpm));
            }

            getTypeEffectiveness(attackType, defenderTypes) {
                if (!this.typeChart) return 1.0;
                
                let effectiveness = 1.0;
                const types = Array.isArray(defenderTypes) ? defenderTypes : [defenderTypes];
                
                types.forEach(defType => {
                    if (this.typeChart[attackType] && this.typeChart[attackType][defType] !== undefined) {
                        effectiveness *= this.typeChart[attackType][defType];
                    }
                });
                
                return effectiveness;
            }

            calculateBattleRating() {
                if (this.hp[0] <= 0 && this.hp[1] <= 0) return 500;
                
                const p1RemainingPercent = Math.max(0, this.hp[0]) / this.maxHP[0];
                const p2RemainingPercent = Math.max(0, this.hp[1]) / this.maxHP[1];
                const differential = p1RemainingPercent - p2RemainingPercent;
                const rating = 500 + (differential * 500);
                
                return Math.max(0, Math.min(1000, rating));
            }

            getLog() {
                return this.log;
            }

            getBattleSummary() {
                return {
                    winner: this.hp[0] > 0 ? 'P1' : (this.hp[1] > 0 ? 'P2' : 'TIE'),
                    rating: this.calculateBattleRating(),
                    turns: this.turn,
                    p1: {
                        hp: this.hp[0],
                        maxHP: this.maxHP[0],
                        hpPercent: (this.hp[0] / this.maxHP[0] * 100).toFixed(1),
                        energy: this.energy[0],
                        shields: this.shields[0]
                    },
                    p2: {
                        hp: this.hp[1],
                        maxHP: this.maxHP[1],
                        hpPercent: (this.hp[1] / this.maxHP[1] * 100).toFixed(1),
                        energy: this.energy[1],
                        shields: this.shields[1]
                    }
                };
            }
        }
    </script>
</body>
</html>